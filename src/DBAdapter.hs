module DBAdapter where

import Database.SQLite.Simple
import Control.Monad.IO.Class
import Control.Monad.Trans.Reader(asks, ask)
import Servant
import Data.String
import Data.Maybe(listToMaybe, isJust)
import Data.List.Split

import Models.Website
import qualified Models.User as UM
import Config

-- | Initialize database with tables if do not already exist
initDB :: AppM IO ()
initDB = do
  config <- ask
  liftIO $ do 
    initQuery <- readFile (initFile config)
    withConnection (dbFile config) (`execute_` composeQuery initQuery)

composeQuery :: String -> Query
composeQuery = foldMap fromString . splitOn ";" 

liftDbAction :: (Connection -> IO a) -> AppM Handler a
liftDbAction = mapReaderT liftIO . dbExec

-- | Execute an action on the database
dbExec :: (Connection -> IO a) -> AppM IO a
dbExec f = do 
  file <- asks dbFile
  liftIO $ withConnection file f

dbAddMessage :: String -> Connection -> IO ()
dbAddMessage msg conn = execute conn "INSERT INTO messages VALUES (?)" (Only msg)

dbGetMessages :: Connection -> IO [String]
dbGetMessages conn = let result = query_ conn "SELECT msg FROM messages"
                     in fmap (map fromOnly) result

-- | Add a website to the database. ID field is generated by database
dbAddWebsite :: Website -> Connection -> IO ()
dbAddWebsite website conn = execute conn insertWebsite (url website, hash website)
  where insertWebsite = "INSERT INTO Websites (URL, LastUpdate, Hash) VALUES (?, NOW(), ?)"

-- | Check if website hash has changed, returns True if it has changed or website is not found
dbCheckWebsiteHash :: Int -> Int -> Connection -> IO Bool
dbCheckWebsiteHash websiteID newHash conn = do 
    result <- query conn checkHash (websiteID, newHash) :: IO [Only Int]
    let (Only count) = head result
    return $ count == 0
  where checkHash = "SELECT COUNT() FROM Websites WHERE WebsiteID = ? AND Hash = ?"

dbUpdateWebsiteHash :: Int -> Int -> Connection -> IO Bool
dbUpdateWebsiteHash websiteID newHash conn = do
    execute conn updateHash (newHash, websiteID)
    (== 1) <$> changes conn
  where updateHash = "UPDATE Websites SET Hash = ?, LastUpdate = NOW() WHERE WebsiteID = ?"


{-| Add a new user to the database, if username is not already in use.
     ID is generated by the database. -}
dbAddUser :: UM.User -> Connection -> IO Bool
dbAddUser user conn = do
    maybeUser <- dbGetUser (UM.username user) conn 
    if isJust maybeUser 
      then return False
      else do 
            execute conn insertUser (UM.username user, UM.password user)
            (== 1) <$> changes conn
  where insertUser = "INSERT INTO Users (Username, Password) VALUES (?, ?)"

-- | Lookup user with given username, if it does not exist Nothing is returned
dbGetUser :: String -> Connection -> IO (Maybe UM.User)
dbGetUser name conn = do
    result <- query conn lookupUser (Only name)
    return $ listToMaybe result
  where lookupUser = "SELECT UserID, Username, Password FROM Users WHERE Username = ?"

-- | Add notification token for user to database
dbAddToken :: UM.User -> String -> Connection -> IO ()
dbAddToken user token conn = do
    execute conn insertToken (UM.id user, token)
  where insertToken = "INSERT INTO NotificationTokens (UserID, Token) VALUES (?, ?)"