module DBAdapter where

import Database.SQLite.Simple
import Control.Monad.IO.Class
import Control.Monad.Reader
import qualified Control.Monad.Trans.Reader as TR
import Servant
import Data.String
import Data.Maybe(listToMaybe)
import Data.List.Split

import qualified Models.Website as WM
import qualified Models.User as UM
import qualified Models.Target as TM
import Config

-- | Initialize database with tables if do not already exist
initDB :: AppM IO ()
initDB = do
  conf <- TR.ask
  liftIO $ do 
    initQuery <- readFile (initFile conf)
    withConnection (dbFile conf) (\conn -> mapM_ (execute_ conn) $ splitQuery initQuery)

splitQuery :: String -> [Query]
splitQuery = map fromString . splitOn ";"

execDB :: (Connection -> IO a) -> IO a
execDB f = do conf <- config
              runReaderT (exec f) conf

liftDbAction :: (Connection -> IO a) -> AppM Handler a
liftDbAction = mapReaderT liftIO . exec

-- | Execute an action on the database
exec :: (Connection -> IO a) -> AppM IO a
exec f = do 
  file <- TR.asks dbFile
  liftIO $ withConnection file f


{- | Add a website to the database, is it not already exists and return its ID. 
     ID field is generated by database -}
addWebsite :: WM.Website -> Connection -> IO Int
addWebsite website conn = do
    maybeWebsite <- getWebsiteByURL (WM.url website) conn
    case maybeWebsite of
      Just w  -> return $ WM.idWebsite w
      Nothing -> do 
        execute conn insertWebsite (WM.url website, WM.hash website)
        fromIntegral <$> lastInsertRowId conn
  where insertWebsite = "INSERT INTO Websites (URL, LastUpdate, Hash) VALUES (?, datetime('now'), ?)"

-- | Lookup if given URL is already in the database
getWebsiteByURL :: String -> Connection -> IO (Maybe WM.Website)
getWebsiteByURL url conn = do
    result <- query conn lookupWebsite (Only url)
    return $ listToMaybe result
  where lookupWebsite = "SELECT WebsiteID, URL, LastUpdate, Hash FROM Websites WHERE URL = ?"

-- | Returns all websites that are in the database
getWebsites :: Connection -> IO [WM.Website]
getWebsites conn = query_ conn allWebsites
  where allWebsites = "SELECT WebsiteID, URL, LastUpdate, Hash FROM Websites"

-- | Check if website hash has changed, returns True if it has changed or website is not found
checkWebsiteHash :: Int -> Int -> Connection -> IO Bool
checkWebsiteHash websiteID newHash conn = do 
    result <- query conn checkHash (websiteID, newHash) :: IO [Only Int]
    let (Only count) = head result
    return $ count == 0
  where checkHash = "SELECT COUNT() FROM Websites WHERE WebsiteID = ? AND Hash = ?"

-- | Update the hash for the given websiteID
updateWebsiteHash :: Int -> Int -> Connection -> IO Bool
updateWebsiteHash websiteID newHash conn = do
    execute conn updateHash (newHash, websiteID)
    (== 1) <$> changes conn
  where updateHash = "UPDATE Websites SET Hash = ?, LastUpdate = datetime('now') WHERE WebsiteID = ?"


{-| Add a new user to the database, if username is not already in use.
     ID is generated by the database. -}
addUser :: UM.User -> Connection -> IO (Maybe Int)
addUser user conn = do
    maybeUser <- getUser (UM.username user) conn 
    case maybeUser of
      Just _  -> return Nothing
      Nothing ->  do
        execute conn insertUser (UM.username user, UM.password user)
        ident <- fromIntegral <$> lastInsertRowId conn
        return $ Just ident
  where insertUser = "INSERT INTO Users (Username, Password) VALUES (?, ?)"

-- | Lookup user with given username, if it does not exist Nothing is returned
getUser :: String -> Connection -> IO (Maybe UM.User)
getUser name conn = do
    result <- query conn lookupUser (Only name)
    return $ listToMaybe result
  where lookupUser = "SELECT UserID, Username, Password FROM Users WHERE Username = ?"

-- | Add notification token for user to database
addToken :: UM.User -> String -> Connection -> IO ()
addToken user token conn =
    execute conn insertToken (UM.id user, token)
  where insertToken = "INSERT INTO NotificationTokens (UserID, Token) VALUES (?, ?)"

-- | Get all users and selectors which are subscribed on given website
getTargetsOnWebsite :: Int -> Connection -> IO [TM.Target]
getTargetsOnWebsite websiteID conn = 
    query conn lookupTargets (Only websiteID)
  where lookupTargets = "SELECT WebsiteID, UserID, Selector FROM Targets WHERE websiteID = ?"