module DBAdapter where

import Database.SQLite.Simple
import Control.Monad.IO.Class
import Control.Monad.Reader
import qualified Control.Monad.Trans.Reader as TR
import Servant
import Data.String
import Data.Maybe(listToMaybe)
import Data.List.Split

import qualified Models.Website as WM
import qualified Models.User as UM
import qualified Models.Target as TM
import qualified Models.Notification as NM
import qualified Models.FullTarget as FTM
import Config

type UserID = Int
type WebsiteID = Int
type TargetID = Int
type URL = String
type Hash = Int
type Token = String

-- | Initialize database with tables if do not already exist
initDB :: AppConfig IO ()
initDB = do
  conf <- TR.ask
  liftIO $ do 
    initQuery <- readFile (initFile conf)
    withConnection (dbFile conf) (\conn -> mapM_ (execute_ conn) $ splitQuery initQuery)

splitQuery :: String -> [Query]
splitQuery = map fromString . splitOn ";"

execDB :: (Connection -> IO a) -> IO a
execDB f = do conf <- config
              runReaderT (exec f) conf

contextDbAction :: (Connection -> IO a) -> AppContext Handler a
contextDbAction = lift . liftDbAction

liftDbAction :: (Connection -> IO a) -> AppConfig Handler a
liftDbAction = mapReaderT liftIO . exec

-- | Execute an action on the database
exec :: (Connection -> IO a) -> AppConfig IO a
exec f = do 
  file <- TR.asks dbFile
  liftIO $ withConnection file f

isSuccessful :: Connection -> IO Bool
isSuccessful = fmap (== 1) . changes

{- | Add a website to the database, is it not already exists and return its ID. 
     ID field is generated by database -}
addWebsite :: WM.Website -> (Connection -> IO Int)
addWebsite website conn = do
    maybeWebsite <- getWebsiteByURL (WM.url website) conn
    case maybeWebsite of
      Just w  -> return $ WM.idWebsite w
      Nothing -> do 
        execute conn insertWebsite (WM.url website, WM.hash website)
        fromIntegral <$> lastInsertRowId conn
  where insertWebsite = "INSERT INTO Websites (URL, LastUpdate, Hash) "
                     <> "VALUES (?, datetime('now'), ?)"

-- | Lookup if given URL is already in the database
getWebsiteByURL :: URL -> (Connection -> IO (Maybe WM.Website))
getWebsiteByURL url conn = do
    result <- query conn lookupWebsite (Only url)
    return $ listToMaybe result
  where lookupWebsite = "SELECT WebsiteID, URL, LastUpdate, Hash "
                     <> "FROM Websites WHERE URL = ?"

-- | Returns all websites that are in the database
getWebsites :: Connection -> IO [WM.Website]
getWebsites conn = query_ conn allWebsites
  where allWebsites = "SELECT WebsiteID, URL, LastUpdate, Hash "
                   <> "FROM Websites"

-- | Check if website hash has changed, returns True if it has changed or website is not found
checkWebsiteHash :: WebsiteID -> Hash -> (Connection -> IO Bool)
checkWebsiteHash websiteID newHash conn = do 
    result <- query conn checkHash (websiteID, newHash) :: IO [Only Int]
    let (Only count) = head result
    return $ count == 0
  where checkHash = "SELECT COUNT() "
                 <> "FROM Websites "
                 <> "WHERE WebsiteID = ? AND Hash = ?"

-- | Update the hash for the given websiteID
updateWebsiteHash :: WebsiteID -> Hash -> (Connection -> IO Bool)
updateWebsiteHash websiteID newHash conn = do
    execute conn updateHash (newHash, websiteID)
    isSuccessful conn
  where updateHash = "UPDATE Websites "
                  <> "SET Hash = ?, LastUpdate = datetime('now') "
                  <> "WHERE WebsiteID = ?"

-- | Check if website hash has changed, returns True if it has changed or website is not found
checkTargetHash :: WebsiteID -> Hash -> (Connection -> IO Bool)
checkTargetHash websiteID newHash conn = do 
    result <- query conn checkHash (websiteID, newHash) :: IO [Only Int]
    let (Only count) = head result
    return $ count == 0
  where checkHash = "SELECT COUNT() "
                 <> "FROM Targets "
                 <> "WHERE WebsiteID = ? AND Hash = ?"

  -- | Update the hash for the given websiteID
updateTargetHash :: WebsiteID -> Hash -> (Connection -> IO Bool)
updateTargetHash websiteID newHash conn = do
    execute conn updateHash (newHash, websiteID)
    (== 1) <$> changes conn
  where updateHash = "UPDATE Targets "
                  <> "SET Hash = ?, "
                  <> "WHERE WebsiteID = ?"

{-| Add a new user to the database, if username is not already in use.
     ID is generated by the database. -}
addUser :: UM.User -> Connection -> IO (Maybe Int)
addUser user conn = do
    maybeUser <- getUser (UM.username user) conn 
    case maybeUser of
      Just _  -> return Nothing
      Nothing ->  do
        execute conn insertUser (UM.username user, UM.password user)
        ident <- fromIntegral <$> lastInsertRowId conn
        return $ Just ident
  where insertUser = "INSERT INTO Users (Username, Password) "
                  <> "VALUES (?, ?)"

-- | Lookup user with given username, if it does not exist Nothing is returned
getUser :: String -> Connection -> IO (Maybe UM.User)
getUser name conn = do
    result <- query conn lookupUser (Only name)
    return $ listToMaybe result
  where lookupUser = "SELECT UserID, Username, Password "
                  <> "FROM Users "
                  <> "WHERE Username = ?"

-- | Add push notification details to the database, consisting of (endpoint, p256dh, auth)
addToken :: UM.User -> NM.SubscriptionDetails -> (Connection -> IO Bool)
addToken user sub conn = do
    execute conn insertToken (UM.id user, NM.endpoint sub, NM.hash sub, NM.auth sub, NM.device sub, NM.browser sub)
    isSuccessful conn
  where insertToken = "INSERT INTO NotificationTokens (UserID, Endpoint, P256dh, Auth, Device, Browser) "
                   <> "VALUES (?, ?, ?, ?, ?, ?)"

-- | Add push notification details to the database, consisting of (endpoint, p256dh, auth)
deleteToken :: UserID -> Token -> (Connection -> IO Bool)
deleteToken userId authToken conn = do 
      execute conn delToken (userId, authToken)
      isSuccessful conn
  where delToken = "DELETE FROM NotificationTokens "
                <> "WHERE UserID = ? AND Auth = ?" 

-- | Get the list of tokens for a user
getTokens :: UserID -> (Connection -> IO [NM.SubscriptionDetails])
getTokens userID conn = query conn lookupTokens (Only userID)
  where lookupTokens = "SELECT Endpoint, P256dh, Auth, Device, Browser "
                    <> "FROM NotificationTokens "
                    <> "WHERE UserID = ?"

-- | Get the list of tokens for a user
getNotificationHistory :: UserID -> (Connection -> IO [NM.Notification])
getNotificationHistory userID conn = query conn lookupTokens (Only userID)
  where lookupTokens = "SELECT W.URL, NT.Message, Timestamp "
                    <> "FROM Notifications AS NT "
                    <> "JOIN Websites AS W ON NT.WebsiteID = W.WebsiteID "
                    <> "WHERE UserID = ? "
                    <> "ORDER BY Timestamp DESC "

-- | Add push notification details to the database, consisting of (endpoint, p256dh, auth)
deleteNotificationHistory :: UserID -> (Connection -> IO Bool)
deleteNotificationHistory userId conn = do 
      execute conn delHistory (Only userId)
      isSuccessful conn
  where delHistory = "DELETE FROM Notifications "
                  <> "WHERE UserID = ?" 


-- | Get all users and selectors which are subscribed on given website
getTargetsOnWebsite :: WebsiteID -> (Connection -> IO [TM.Target])
getTargetsOnWebsite websiteID conn = 
    query conn lookupTargets (Only websiteID)
  where lookupTargets = "SELECT TargetID, UserID, WebsiteID, Selector "
                     <> "FROM Targets "
                     <> "WHERE websiteID = ?"

-- | Add given target to the database and returns if the action was successful
addTarget :: TM.Target -> (Connection -> IO Bool)
addTarget target conn = do execute conn insertTarget target
                           isSuccessful conn
  where insertTarget = "INSERT INTO Targets (UserID, WebsiteID, Selector, Hash) "
                    <> "VALUES (?,?,?,?)"

-- | Update the website and/or selector of the given target and return if the action was successful
editTarget :: TM.Target -> (Connection -> IO Bool)
editTarget t conn = do execute conn updateTarget (TM.websiteID t, TM.selector t, TM.hash t, TM.id t)
                       isSuccessful conn
  where updateTarget = "UPDATE Targets "
                    <> "SET WebsiteID = ?, Selector = ?, Hash = ? "
                    <> "WHERE TargetID = ?"

-- | Delete the target with the given id from the database
removeTarget :: TargetID -> (Connection -> IO Bool)
removeTarget targetID conn = do execute conn deleteTarget (Only targetID)
                                isSuccessful conn
  where deleteTarget = "DELETE FROM Targets "
                    <> "WHERE TargetID = ?" 

-- | Get specific target
getTarget :: TargetID -> (Connection -> IO (Maybe TM.Target))
getTarget targetId conn = do
    result <- query conn lookupTarget (Only targetId)
    return $ listToMaybe result
  where lookupTarget = "SELECT TargetID, UserID, WebsiteID, Selector, Hash "
                    <> "FROM Targets "
                    <> "WHERE TargetID = ?"

-- | Get all targets of given user 
getTargetsOfUser :: UserID -> (Connection -> IO [FTM.FullTarget])
getTargetsOfUser userID conn = 
    query conn lookupTargets (Only userID)
  where lookupTargets = "SELECT T.TargetID, T.UserID, T.WebsiteID, W.URL, W.LastUpdate, T.Selector "
                     <> "FROM Targets AS T "
                     <> "JOIN Websites AS W ON T.WebsiteID = W.WebsiteID "
                     <> "WHERE UserID = ?"

-- | Checks if there are websites in the database that are not targeted, so they can be removed
removeUnusedWebsites :: Connection -> IO Int
removeUnusedWebsites conn = do execute_ conn deleteWebsites
                               changes conn
  where deleteWebsites = "DELETE FROM Websites "
                      <> "WHERE Websites.WebsiteID NOT IN (SELECT WebsiteID FROM Targets)" 

